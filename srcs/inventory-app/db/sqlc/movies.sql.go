// Code generated by sqlc. DO NOT EDIT.
// source: movies.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createMovie = `-- name: CreateMovie :one
INSERT INTO "movies" (
    "id",
    "title",
    "description"
) VALUES (
    $1, $2, $3
)RETURNING id, title, description
`

type CreateMovieParams struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (Movie, error) {
	row := q.db.QueryRowContext(ctx, createMovie, arg.ID, arg.Title, arg.Description)
	var i Movie
	err := row.Scan(&i.ID, &i.Title, &i.Description)
	return i, err
}

const deleteMovieById = `-- name: DeleteMovieById :one
DELETE FROM "movies" WHERE "id" = $1 RETURNING id, title, description
`

func (q *Queries) DeleteMovieById(ctx context.Context, id uuid.UUID) (Movie, error) {
	row := q.db.QueryRowContext(ctx, deleteMovieById, id)
	var i Movie
	err := row.Scan(&i.ID, &i.Title, &i.Description)
	return i, err
}

const deleteMovies = `-- name: DeleteMovies :many
DELETE FROM "movies" RETURNING id, title, description
`

func (q *Queries) DeleteMovies(ctx context.Context) ([]Movie, error) {
	rows, err := q.db.QueryContext(ctx, deleteMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(&i.ID, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieById = `-- name: GetMovieById :one
SELECT id, title, description FROM "movies" WHERE "id" = $1
`

func (q *Queries) GetMovieById(ctx context.Context, id uuid.UUID) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieById, id)
	var i Movie
	err := row.Scan(&i.ID, &i.Title, &i.Description)
	return i, err
}

const getMovies = `-- name: GetMovies :many
SELECT id, title, description FROM "movies"
`

func (q *Queries) GetMovies(ctx context.Context) ([]Movie, error) {
	rows, err := q.db.QueryContext(ctx, getMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(&i.ID, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovieById = `-- name: UpdateMovieById :one
UPDATE "movies" SET "title" = $2, "description" = $3 WHERE "id" = $1 RETURNING id, title, description
`

type UpdateMovieByIdParams struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
}

func (q *Queries) UpdateMovieById(ctx context.Context, arg UpdateMovieByIdParams) (Movie, error) {
	row := q.db.QueryRowContext(ctx, updateMovieById, arg.ID, arg.Title, arg.Description)
	var i Movie
	err := row.Scan(&i.ID, &i.Title, &i.Description)
	return i, err
}
